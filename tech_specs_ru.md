# Техническое задание для реализации сервисов с использованием Apache Kafka, Django, Celery

## Введение

Целью данного проекта является создание двух сервисов, связанных посредством Apache Kafka, для обработки и анализа чеков покупок. Первый сервис отвечает за прием, валидацию и запись чеков в журнал, а также их передачу второму сервису. Второй сервис разбивает содержимое чеков на привязку к местам покупок, считает аналитику и предоставляет данные по API.

## 1. Первый сервис (Producer)

### 1.1 Функциональность

#### 1.1.1 Прием чеков покупок с клиентов.

#### 1.1.2 Валидация чеков: проверка на корректность формата и соответствие ожидаемой структуре.

Структура чека:

```jsonc
{
  "transaction_id": "unique_transaction_id",
  "timestamp": "2024-02-07T12:34:56",
  "items": [
    {
      "product_id": "product_id_1",
      "quantity": 2,
      "price": 10.99,
      "category": "groceries"
    },
    {
      "product_id": "product_id_2",
      "quantity": 1,
      "price": 5.49,
      "category": "electronics"
    }
    // Дополнительные товары
  ],
  "total_amount": 27.47,
  "nds_amount": 2.47, // Сумма НДС
  "tips_amount": 3.0, // Сумма чаевых (если применимо)
  "payment_method": "credit_card"
  // Дополнительные поля по необходимости
}
```

Обязательные поля:

- `transaction_id`: уникальный идентификатор транзакции.
- `timestamp`: временная метка совершения покупки.
- `items`: список товаров в чеке.
- `product_id`: уникальный идентификатор товара.
- `quantity`: количество товара.
- `price`: цена товара.
- `category`: категория товара.
- `total_amount`: общая сумма чека.
- `nds_amount`: сумма НДС.
- `tips_amount`: сумма чаевых (если применимо).
- `payment_method`: метод оплаты.

#### 1.1.3 Запись в журнал всех полученных чеков.

#### 1.1.4 Отправка чеков второму сервису посредством Apache Kafka.

### 1.2 Технологии

1. **Django** - для создания API для приема чеков.
2. **Apache Kafka** - для отправки сообщений второму сервису.
3. **Logging** - логирование событий в чеках для последующего анализа (в СУБД).
4. **СУБД** - PostgreSQL

## 2. Второй сервис (Consumer)

### 2.1 Функциональность

#### 2.1.1 Прием чеков из первого сервиса посредством Apache Kafka.

#### 2.1.2 Разбиение содержимого чеков на привязку к местам покупок и дополнительной информации (например, категории покупок).

Структура аналитики:

```jsonc
{
  "place_id": "unique_place_id",
  "place_name": "Store ABC",
  "total_purchases": 150,
  "average_receipt": 35.75,
  "taxes_amount": {
    "total_nds": 275.0,
    "total_tips": 150.0
  },
  "category_analytics": {
    "groceries": {
      "total_spent": 5000.0,
      "average_receipt": 25.0
    },
    "electronics": {
      "total_spent": 3000.0,
      "average_receipt": 50.0
    }
    // Другие категории
  }
  // Другие метрики
}
```

Обязательные поля:

- `place_id`: уникальный идентификатор места покупки.
- `place_name`: название места покупки.
- `total_purchases`: общее количество покупок в данном месте.
- `average_receipt`: средний чек в данном месте.
- `taxes_amount`: сумма налогов и чаевых.
- `total_nds`: общая сумма НДС за промежуток времени.
- `total_tips`: общая сумма чаевых за промежуток времени.
- `category_analytics`: аналитика по категориям товаров.
- `total_spent`: общая сумма потраченная на категорию за промежуток времени.
- `average_receipt`: средний чек по категории.

#### 2.1.3 Сохранение данных в БД.

#### 2.1.4 Расчет аналитики:

- Количество покупок в каждом месте.
- Средний чек в каждом месте.
- Общая сумма налогов и чаевых за промежуток времени.
- Аналитика по категориям товаров.

#### 2.1.5 Запуск расчетов аналитики каждый час с использованием Celery.

## 2.2 Технологии

1. **Django** - для создания API для обработки чеков и предоставления данных.
2. **Apache Kafka** - для приема сообщений от первого сервиса.
3. **СУБД** - PostgreSQL.
4. **Celery** - для периодического запуска задач по расчету аналитики.

## 3. API

### 3.1 Эндпоинты

### 3.1.1 Первый сервис:

- `POST /api/checks/` - прием чеков.

### 3.1.2 Второй сервис:

- `GET /api/places/` - получение списка мест покупок.
- `GET /api/analytics/` - получение общей аналитики.
- Дополнительные эндпоинты по необходимости.

### 3.2 Авторизация

- Использование токенов для аутентификации и авторизации.
- Разграничение доступа к различным частям API в зависимости от ролей.

## 4. Документация

- Создание документации по API с использованием Swagger или другого инструмента.
- Документация по развертыванию и конфигурации сервисов.

## 5. Контейнеризация

Обязательно условие выполнения тестового задания - это собрать окончательное решение, используя Docker

## 6. Заключение

Цель проекта - обеспечение эффективного обмена и обработки данных о чеках покупок между двумя сервисами. Сервисы должны быть масштабируемыми, надежными и обеспечивать удобный доступ к аналитическим данным через API.
